import { Injectable } from '@angular/core';
import * as XLSX from 'xlsx';

export interface ProductoExcel {
  id: number;
  nombre: string;
  precio: number;
  imagen: string;
  descripcion: string;
  tipo: string;
  disponible: number; // 0 = no disponible, 1 = disponible
}

@Injectable({
  providedIn: 'root'
})
export class ExcelReaderService {

  constructor() { }

  async leerProductosDesdeExcel(): Promise<ProductoExcel[]> {
    try {
      console.log('üöÄ INICIANDO LECTURA DE EXCEL...');
      
      const response = await fetch('/Descriptions.xlsx');
      
      if (!response.ok) {
        throw new Error(`HTTP Error: ${response.status} ${response.statusText}`);
      }
      
      console.log('‚úÖ Archivo Excel descargado correctamente');
      
      const arrayBuffer = await response.arrayBuffer();
      console.log(`üìä Tama√±o del archivo: ${arrayBuffer.byteLength} bytes`);
      
      const workbook = XLSX.read(arrayBuffer, { type: 'array' });
      console.log('üìã Hojas disponibles:', workbook.SheetNames);
      
      // Buscar hoja v√°lida (priorizar Hoja3)
      let worksheet = workbook.Sheets['Hoja3'] || workbook.Sheets['Hoja1'] || workbook.Sheets['Sheet1'];
      
      if (!worksheet) {
        throw new Error('No hay hojas v√°lidas en el Excel');
      }
      
      const nombreHoja = workbook.SheetNames.find(name => workbook.Sheets[name] === worksheet) || 'desconocida';
      console.log(`‚úÖ Usando hoja: "${nombreHoja}"`);
      
      const jsonData = XLSX.utils.sheet_to_json(worksheet);
      console.log(`üìÑ ${jsonData.length} filas encontradas`);
      
      if (jsonData.length === 0) {
        throw new Error('La hoja Excel no contiene datos');
      }
      
      // Mostrar estructura de la primera fila
      const primeraFila = jsonData[0] as Record<string, any>;
      console.log('üìã Columnas:', Object.keys(primeraFila));
      console.log('üìã Ejemplo:', primeraFila);
      
      // Procesar productos
      const productos: ProductoExcel[] = [];
      
      for (let i = 0; i < jsonData.length; i++) {
        const row = jsonData[i] as Record<string, any>;
        
        // FILTRO: Ignorar productos sin precio
        const precioRaw = row['precio'] || row['Precio'] || row['price'] || row['Price'];
        const tienePrecio = precioRaw && 
                           precioRaw !== '' && 
                           precioRaw !== 0 && 
                           precioRaw !== '0' &&
                           !isNaN(parseFloat(precioRaw.toString().replace(/[,$]/g, '')));
        
        if (!tienePrecio) {
          console.log(`‚ùå FILA ${i + 1} IGNORADA - Sin precio v√°lido:`, precioRaw);
          continue;
        }
        
        const imagenRaw = this.parseString(row["imagen"] || row["Imagen"] || row["image"] || row["Image"]);
        const producto: ProductoExcel = {
          id: this.parseNumber(row["id"] || row["Id"] || row["ID"]),
          nombre: this.parseString(row["nombre"] || row["Nombre"] || row["name"] || row["Name"]),
          precio: this.parseNumber(row["precio"] || row["Precio"] || row["price"] || row["Price"]),
          imagen: this.normalizarRutaImagen(imagenRaw),
          descripcion: this.parseString(row["descripcion"] || row["Descripcion"] || row["description"] || row["Description"]),
          tipo: this.parseString(row["tipo"] || row["Tipo"] || row["category"] || row["Category"]).toLowerCase(),
          disponible: this.parseNumber(row["disponible"] || row["Disponible"] || row["available"] || row["Available"])
        };
        
        // Validar y agregar solo productos v√°lidos
        if (producto.id > 0 && producto.nombre && producto.precio > 0 && producto.imagen) {
          productos.push(producto);
          console.log(`‚úÖ ${i + 1}. "${producto.nombre}" ‚Üí $${producto.precio}`);
        } else {
          console.warn(`‚ö†Ô∏è Producto inv√°lido en fila ${i + 1}:`, {
            id: producto.id,
            nombre: producto.nombre,
            precio: producto.precio,
            imagen: producto.imagen
          });
        }
      }
      
      console.log(`‚úÖ PROCESADOS ${productos.length} productos v√°lidos de ${jsonData.length} filas`);
      
      if (productos.length === 0) {
        // Fallback con producto de ejemplo
        return [{
          id: 1,
          nombre: 'Producto de Ejemplo',
          precio: 99.99,
          imagen: '/23712_890.jpg',
          descripcion: 'Producto cargado desde Excel',
          tipo: 'juguetes'
        }];
      }
      
      return productos;
      
    } catch (error) {
      console.error('üí• ERROR en lectura de Excel:', error);
      throw error;
    }
  }

  organizarProductosPorTipo(productos: ProductoExcel[]): { [key: string]: ProductoExcel[] } {
    console.log('üèóÔ∏è Organizando productos por tipo...');
    
    const productosOrganizados: { [key: string]: ProductoExcel[] } = {
      juguetes: [],
      ropa: [],
      electronica: [],
      hogar: [],
      deportes: []
    };

    productos.forEach(producto => {
      const tipo = this.normalizarTipo(producto.tipo);
      productosOrganizados[tipo].push(producto);
      console.log(`üì¶ ${producto.nombre} ‚Üí ${tipo}`);
    });

    console.log('‚úÖ Organizaci√≥n completada');
    return productosOrganizados;
  }

  private normalizarTipo(tipo: string): string {
    const tipoLimpio = tipo.toLowerCase().trim();
    
    if (tipoLimpio.includes('juguete') || tipoLimpio.includes('toy')) return 'juguetes';
    if (tipoLimpio.includes('ropa') || tipoLimpio.includes('clothing') || tipoLimpio.includes('fashion')) return 'ropa';
    if (tipoLimpio.includes('electronic') || tipoLimpio.includes('tech') || tipoLimpio.includes('tecnolog')) return 'electronica';
    if (tipoLimpio.includes('hogar') || tipoLimpio.includes('home') || tipoLimpio.includes('casa')) return 'hogar';
    if (tipoLimpio.includes('deporte') || tipoLimpio.includes('sport') || tipoLimpio.includes('fitness')) return 'deportes';
    
    return 'juguetes'; // Default
  }

  private parseNumber(value: any): number {
    if (typeof value === 'number') return value;
    if (typeof value === 'string') {
      const parsed = parseFloat(value.replace(/[,$]/g, ''));
      return isNaN(parsed) ? 0 : parsed;
    }
    return 0;
  }

  private parseString(value: any): string {
    if (typeof value === 'string') return value.trim();
    if (value !== null && value !== undefined) return String(value).trim();
    return '';
  }

  private normalizarRutaImagen(imagenRaw: string): string {
    if (!imagenRaw) return '';
    
    // Lista de archivos que existen en public/ con extensiones mixtas
    const archivosExistentes = [
      '0_190.JPG', '0_400.jpg', '16431_450.JPG', '17292_259.JPG', 
      '18452_150.JPG', '23712_890.jpg', '54535_110.JPG', '5913_249.JPG',
      '60498_185.JPG', '6118_249.JPG', '67764_250.JPG', '67887_560.JPG',
      '71590_185.JPG', '71613_180.JPG', '71613_185.JPG', '71774_150.JPG',
      '72702_149.JPG', '74511_370.JPG', '76133_260.JPG', '76355_298.JPG',
      '80367_150.JPG', '80812_180.JPG', '80898_160.JPG', '81261_180.JPG',
      '81963_350.JPG', '91989_485.JPG', '93541_296.JPG'
    ];
    
    // Limpiar la ruta
    let nombreLimpio = imagenRaw.startsWith('/') ? imagenRaw.substring(1) : imagenRaw;
    
    // Buscar el archivo que realmente existe (probando ambas extensiones)
    const archivoEncontrado = archivosExistentes.find(archivo => {
      // Comparar sin extensi√≥n
      const sinExtension = archivo.split('.')[0];
      const nombreSinExtension = nombreLimpio.split('.')[0];
      return sinExtension === nombreSinExtension;
    });
    
    if (archivoEncontrado) {
      const rutaNormalizada = '/' + archivoEncontrado;
      console.log(`üñºÔ∏è Imagen: ${imagenRaw} ‚Üí ${rutaNormalizada} ‚úÖ`);
      return rutaNormalizada;
    }
    
    // Si no se encuentra, usar la ruta original
    const rutaOriginal = '/' + nombreLimpio;
    console.log(`üñºÔ∏è Imagen: ${imagenRaw} ‚Üí ${rutaOriginal} ‚ö†Ô∏è (no encontrada)`);
    return rutaOriginal;
  }
}
